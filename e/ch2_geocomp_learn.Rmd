---
title: "Geocomputation in R: Chapter 2 - Geographic Data in R"
output: html_notebook
---

Set Up
```{r}
rm(list = ls())
pacman::p_load(sf, raster, spDataLarge, spData,leaflet, sp)
```

# 2.1 Vector Data 
Using 'world' dataset provided by spData (to see all datasets loaded: nowosad.github.io/spData)

## 2.1.1 Intro to sf 

World is a spatial object containing spatial and attribute columns, check those out:
```{r}
names(world)
```
Visualize (sp equivalent is spplot())
```{r}
plot(world)
```

Summary works to provide an overview of vars within 'world' object
```{r}
summary(world)
```

sf objects easy to subset (geometry alwasy kept unless deliberately removed, thus do not need to include geom col when subsetting)
```{r}
world[1:2,1:3]
```


## 2.1.2 Why sf? 
Can convert sf objects to spatial class used in sp if necessary (e.g. using a package that doesn't support sf objects yet)
```{r}
world_sp <- as(world, Class = "Spatial")
```

Can convert back to sf in same way or:
```{r}
world_sf <- st_as_sf(world_sp,"sf")
```


## 2.1.3 basic map making 

Plot 2 variables
```{r}
plot(world[3:4])
```



Plot 1 variable
```{r}
plot(world["pop"])
```

We will subset and combine countries in the world object, which creates a single object representing Asia:
```{r}
asia <- world[world$continent == "Asia",]
asia <- st_union(asia)
```


We can now plot the Asian continent over a map of the world. 
Note, however, that this only works if the initial plot has only one layer:
*this code correct now -- reported as an issue -- that this only works when the initial plot has only one facet and when reset (which resets plot settings) is set to FALSE
```{r}
plot(world["pop"],reset = FALSE)
plot(asia,add=TRUE,col="red")
```

## 2.1.4 Base plot arguments

We will see one way of how to do a spatial overlay in sf. First, we convert the countries of the world into centroids, and then subset those in Asia. Finally, the summary command tells us how many centroids (countries) are part of Asia (43) and how many are not (134).
```{r}
world_centroids <-  st_centroid(world)
sel_asia <- st_intersects(world_centroids,asia,sparse=FALSE)
```

So how many centroids (countries) aer part of asia an how many are not?
```{r}
summary(sel_asia)
```

To make the area of circles proportional to population, the cex argument can be used as follows (see Figure 2.6 created with the code below and the exercises in section 2.5):
*this code correct now -- reported as an issue and bug was fixed

```{r}
world_proj = st_transform(world, "+proj=eck4")
world_cents = st_centroid(world_proj, of_largest_polygon = TRUE)
par(mar = c(0, 0, 0, 0))
plot(world_proj["continent"], reset = FALSE, main = "", key.pos = NULL)
g = st_graticule()
g = st_transform(g, crs = "+proj=eck4")
plot(g$geometry, add = TRUE, col = "lightgrey")
cex = sqrt(world$pop) / 10000
#To get black circles:
plot(st_geometry(world_cents), add = TRUE, cex = cex, lwd = 2, graticule = T)
#To get colored circles:
#plot((world_centroids_largest), add = TRUE, cex = sqrt(world$pop)/10000, lwd = 2)
```

## 2.1.6 Simple feature geometries -  (sfg) objects

Can create sfg objects from 3 R native data types - numeric vectors, matrices, and lists
#### 1. to create points from numeric vectors:

```{r}
#2D point
st_point(c(5, 2)) # XY point
#3D point
st_point(c(5, 2, 3)) # XYZ point
#3D point
st_point(c(5, 2, 1), dim = "XYM") # XYM point, only XYM type needs to be specified using a dim argument.
#4D point
st_point(c(5, 2, 3, 1)) # XYZM point
```



#### 2. to create multipoint and linestring objects from matrices:
the rbind function simplifies the creation of matrices
```{r}
## MULTIPOINT
multipoint_matrix = rbind(c(5, 2), c(1, 3), c(3, 4), c(3, 2))
st_multipoint(multipoint_matrix)

## LINESTRING
linestring_matrix = rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2))
st_linestring(linestring_matrix)

```


#### 3. to create multilinestrings, (multi-)polygons and geometry collections, use lists
```{r}
## MULTILINESTRING
multilinestring_list = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), 
                            rbind(c(1, 2), c(2, 4)))
st_multilinestring((multilinestring_list))

## POLYGON
polygon_list = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))
st_polygon(polygon_list)

## POLYGON with a hole - ?? I wonder if important to create border and hole separate then join in a list or if can create in same way a multipolygon created below; likely just illustrative on their part
polygon_border = rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))
polygon_hole = rbind(c(2, 4), c(3, 4), c(3, 3), c(2, 3), c(2, 4))
polygon_with_hole_list = list(polygon_border, polygon_hole)
st_polygon(polygon_with_hole_list)

## MULTIPOLYGON
multipolygon_list = list(list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5))),
                         list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2))))
st_multipolygon(multipolygon_list)

## GEOMETRYCOLLECTION
gemetrycollection_list = list(st_multipoint(multipoint_matrix),
                              st_linestring(linestring_matrix))
st_geometrycollection(gemetrycollection_list)

```


## 2.1.7 Simple frature geometry columns (sfc) 
One sfg object contains only a single simple feature geometry. A simple feature geometry column (sfc) is a list of sfg objects, which is additionally able to contain information about the coordinate reference system in use. For instance, to combine two simple features into one object with two features, we can use the st_sfc() function. This is important since sfc represents the geometry column in sf data frames.
In most cases, an sfc object contains objects of the same geometry type:
```{r}
# sfc POINT: taking 2 points, or 2 objects,  and combining into one object with 2 features
point1 = st_point(c(5, 2))
point2 = st_point(c(1, 3))
points_sfc = st_sfc(point1, point2)
points_sfc

# sfc POLYGON
polygon_list1 = list(rbind(c(1, 5), c(2, 2), c(4, 1), c(4, 4), c(1, 5)))
polygon1 = st_polygon(polygon_list1)
polygon_list2 = list(rbind(c(0, 2), c(1, 2), c(1, 3), c(0, 3), c(0, 2)))
polygon2 = st_polygon(polygon_list2)
st_sfc(polygon1, polygon2)

# sfc MULTILINESTRING
multilinestring_list1 = list(rbind(c(1, 5), c(4, 4), c(4, 1), c(2, 2), c(3, 2)), 
                             rbind(c(1, 2), c(2, 4)))
multilinestring1 = st_multilinestring((multilinestring_list1))
multilinestring_list2 = list(rbind(c(2, 9), c(7, 9), c(5, 6), c(4, 7), c(2, 7)), 
                             rbind(c(1, 7), c(3, 8)))
multilinestring2 = st_multilinestring((multilinestring_list2))
st_sfc(multilinestring1, multilinestring2)

```

It is also possible to create sfc objects from sfg objects with different geometry types --> sfc geometry objects
```{r}
# sfc GEOMETRY
point_multilinestring_sfc = st_sfc(point1, multilinestring1)
st_geometry_type(point_multilinestring_sfc)

```


sfc objects can additionally store information on the coordinate reference systems (CRS). To specify a certain CRS, we can use the epsg (SRID) or proj4string attributes of an sfc object. 
The default value of epsg (SRID) and proj4string is NA (Not Available) (saw this when running this section of code)
```{r}
st_crs(points_sfc)
```

**IMPORTANT NOTE: All geometries in an sfc object must have the same CRS**

Can add coordinate reference system as a crs argument of st_sfc() 
This argument accepts either an integer with the epsg code (for example, 4326) or a proj4string character string (for example, "+proj=longlat +datum=WGS84 +no_defs")
```{r}
# EPSG definition
points_sfc_wgs = st_sfc(point1, point2, crs = 4326)
st_crs(points_sfc_wgs)

# PROJ4STRING definition
st_sfc(point1, point2, crs = "+proj=longlat +datum=WGS84 +no_defs")

```


For example, we can set the UTM Zone 11N projection with epsg code 2955: will see that proj4string definition automatically added
```{r}
st_sfc(point1, point2, crs = 2955)
```

Doing same as above using proj4string definition -- epsg string of result remained empty bc no general method to convert
```{r}
# from proj4string to epsg
st_sfc(point1, point2, crs = "+proj=utm +zone=11 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 +units=m +no_defs")
```

## 2.1.8 The sf class
Objects of class sf represent data by combining attributes (data.frame) with a simple feature geometry column (sfc). They are created with st_sf() as illustrated below, which creates a London example of temperature.
```{r}
lnd_point = st_point(c(0.1, 51.5))                 # sfg object
lnd_geom = st_sfc(lnd_point, crs = 4326)           # sfc object
lnd_attrib = data.frame(                           # data.frame object
  name = "London",
  temperature = 25,
  date = as.Date("2017-06-21")
  )
lnd_sf = st_sf(lnd_attrib, geometry = lnd_geom)    # sf object
lnd_sf
class(lnd_sf)
```
Most of the time a sf can be treated as and behaves like a data.frame. Simple features are, in essence, data frames with a spatial extension.

# 2.2 Raster Data
The geographic raster data model usually consists of a raster header and a matrix (with rows and columns) representing equally spaced cells (often also called pixels). Each cell in a raster layer can only hold a single value, which can be numeric or categorical.

* **Raster header**
    + Defines the coordinate reference system, the extent and the origin.
        - *The origin* (or starting point) is frequently the coordinate of the lower-left corner of the matrix (the raster package, however, uses the upper left corner, by default
        - *The extent* is defined via the number of columns, the number of rows and the cell size resolution. This allows us to easily access and modify each single cell by either using the ID of a cell or by explicitly specifying the rows and columns 
        
## 2.2.1 An introduction to raster
Using data from spDataLarge covering Zion National Park (Utah). The following is a digital elevation model of the are and we will create a `RasterLayer` object for it.
```{r}
raster_filepath = system.file("raster/srtm.tif", package = "spDataLarge")
new_raster = raster(raster_filepath)
```

Print raster header (extent, dimensions, resolution, CRS) and additional info too:
```{r}
new_raster
```
 
This raster unprojected, thus hard to interpret resolution. Good resou<rce on understanding the relationship between raster resolution, spatial extent & number of pixels here: <https://www.neonscience.org/raster-res-extent-pixels-r>

## 2.2.2 Basic map making

Similar to the sf package, raster also provides plot() methods for its own classes.
```{r}
plot(new_raster)
```

## 2.2.3 Raster classes
There are three raster classes:

1.  `RasterLayer` - represents the simplest form of a raster object, and consists of only one layer. The easiest way to create a raster object in R is to read-in a raster file from disk or from a server as done in the code from section [2.2.1 An introduction to raster].

`RasterLayer` rasters can also be created from scratch using the `raster()` function. This is illustrated in the subsequent code chunk, which results in a new `RasterLayer` object. The resulting raster consists of 36 cells (6 columns and 6 rows specified by `nrow` and `ncol`) centered around the Prime Meridian and the Equator (see `xmn`, `xmx`, `ymn` and `ymx` parameters). The CRS is the **default of raster objects: WGS84**. This means the unit of the resolution is in degrees which we set to 0.5 (`res`). Values (`vals`) are assigned to each cell: 1 to cell 1, 2 to cell 2, and so on. **Remember: `raster()` fills cells row-wise** (unlike matrix()) starting at the upper left corner, meaning the top row contains the values 1 to 6, the second 7 to 12 etc.
```{r}
new_raster2 = raster(nrow = 6, ncol = 6, res = 0.5, 
                     xmn = -1.5, xmx = 1.5, ymn = -1.5, ymx = 1.5,
                     vals = 1:36)
new_raster2
```
Plot newly created raster
```{r}
plot(new_raster2)
text(new_raster2)
```


2.  `RasterBrick` -  consists of multiple layers, which typically correspond to a single multispectral satellite file or a single multilayer object in memory. The `brick()` function creates a `RasterBrick` object. Usually, you provide it with a filename to a multilayer raster file but might also use another raster object and other spatial objects. Processing time is usually shorter for `RasterBrick` objects compares to `RasterStack` objects
```{r}
multi_raster_file = system.file("raster/landsat.tif", package = "spDataLarge")
r_brick = brick(multi_raster_file)
r_brick
```
```{r}
#nlayers() retrieves the number of layers stored in a Raster* object:
nlayers(r_brick)
```

3.  `RasterStack` - similar to a `RasterBrick` in the sense that it consists also of multiple layers. However, in contrast to `RasterBrick`, `RasterStack` allows you to connect several raster objects stored in different files or multiply objects in memory. More specifically, a `RasterStack` is a list of `RasterLayer` objects with the same extent and resolution. Hence, one way to create it is with the help of spatial objects already existing in R’s global environment. And again, one can simply specify a path to a file stored on disk. `RasterStack` objects usually have a longer processing time compared to `RasterBrick` objects.
```{r}
#Creating 1st RasterLayer
raster_on_disk = raster(r_brick, layer = 1)
raster_in_memory = raster(xmn = 301905, xmx = 335745,
                          ymn = 4111245, ymx = 4154085, 
                          res = 30)
values(raster_in_memory) = sample(seq_len(ncell(raster_in_memory)))
crs(raster_in_memory) = crs(raster_on_disk)
raster_in_memory
```
Now create a `RasterStack`
```{r}
r_stack = stack(raster_in_memory, raster_on_disk)
r_stack
```

# 2.3 Coordinate Reference Systems (CRSs)
## 2.3.1 Geographic coordinate systems
Geographic coordinate systems identify any location on the Earth’s surface using two values — longitude and latitude. Distance in geographic CRSs are therefore not measured in meters.

* **Longitude**
    + Location in the East-West direction in angular distance from the Prime Meridian plane.
* **Latitude**
    + Angular distance North or South of the equatorial plane.
* **Geographic cordinate system surfaces**
    + *Spherical model:* simple, but innacurate since Earth not a sphere
    + *Ellipsoidal model:* defined by 2 parameters:
        1.  Equatorial radius (~11.5 km longer than polar radius)
        2.  Polar radius

* **Datum**
    + Important component of CRS
    + Pertain to ellipsoidal models of the Earth's surface
    + Specify which ellipsoid model to use (with the `ellps` parameter in the proj4 CRS library)
    + Define the precise relationship between Cartesian coordinates and location on Earth's surface (stored in the `towgs84` argument of proj4 notation)
    + 2 types of datum:
        1.  *Local:* the ellipsoidal surface is shifted to align with the surface at a particular location (ex. `NAD83` for North America), this allows for local variations in Earth's surface, e.g. mountain ranges
        2.  *Geocentric:* the ellipsoidal model center is the Earth's center of gravity and accuracy of projections is not optimized for a specific location (ex. `WGS84`)
    + Available datum definitions can be seen by executing `st_proj_info(type = "datum")`
    
## 2.3.2 Projected coordinate systems (Projected CRSs)
Projected CRSs are based on Cartesian coordinates on an implicitly flat surface. They have an origin, x and y axes, and a linear unit of measurement such as meters. All projected CRSs are based on a geographic CRS, [2.3.1 Geographic coordinate systems], and rely on map projections to convert the three-dimensional surface of the Earth into Easting and Northing (x and y) values in a projected CRS.

* Transition to a projected CRS cannot be done without distortion of some proprties of the Earth's surface. For example:
    + Area
    + Direction
    + Distance
    + Shape
* A projected CRS can preserve only 1-2 of those properties. 
* Projection names often named based on the property they preserve: 
    + *Equal-area* preserves area
    + *Azimuthal* preserve direction
    + *Equidistant* preserve distance
    + *Conformal* preserve local shape
* 3 Main groups of projection types:
    1.  **Conic**
        + Earth's surface is projected onto a cone along a single line of tangency or two lines of tangency. 
        + Distortions are minimized along the tangency lines and rise with the distance from those lines in this projection.
        + Therefore, it is the best suited for maps of mid-latitude areas.
    2.  **Cylindrical**
        + Maps the surface onto a cylinder. 
        + This projection could also be created by touching the Earth's surface along a single line of tangency or two lines of tangency. 
        + Cylindrical projections are used most often when mapping the entire world.
    3.  **Planar**
        + Projects data onto a flat surface touching the globe at a point or along a line of tangency. 
        + Typically used in mapping polar regions.
* `st_proj_info(type = "proj")` gives a list of the available projections supported by the PROJ library.

## 2.3.3 CRSs in R
Two main ways to describe a CRS in R:

  1. `epsg` code
      * Usually shorter than `proj4string` definition, thus easier to remember
      * Code refers to only one, well-defined coordinate reference system
      * Cannot be used to define raster CRS
  2.  `proj4string` definition
      * Allows for more flexibility than `epsg` code when it comes to specifying different parameters such as the projection type, the datum and the ellipsoid
      * You can specify many different projectsion, and modify existing ones
      * The above advantages also make this approach more complicated than using an `epsg` code
      * Raster objects only accept `proj4` definitions
* A quick way to find out about available CRS is viar the `rgdal::make_EPSG()` function
* The following code will show available CRSs interactively, allowing you to filter ones of interest:
```{r}
crs_data <- rgdal::make_EPSG()
View(crs_data)
```

In `sf` the CRS of an object can be retrieved using `st_crs()`. For this, we need to read-in a vector dataset:
```{r}
vector_filepath = system.file("vector/zion.gpkg", package="spDataLarge")
#Polygon representing the borders of Zion National Park
new_vector = st_read(vector_filepath)
```

Now get the CRS of `new_vector`
```{r}
st_crs(new_vector)
```

If CRS is missing or incorrectly set, the `st_set_crs()` function can be used.
```{r}
new_vector <- st_set_crs(new_vector, 26912) #set CRS using EPSG code
```

You may get a warning message that informs us that the st_set_crs() function does not transform data from one CRS to another.

The `projection()` function can be used to access CRS information from a `Raster` object:
```{r}
projection(new_raster) #get CRS
```

The same function, `projection()`, is used to set a CRS for raster objects. The main difference, compared to vector data, is that **raster objects only accept** `proj4` **definitions**:
```{r}
projection(new_raster) = "+proj=utm +zone=12 +ellps=GRS80 +towgs84=0,0,0,0,0,0,0 
                            +units=m +no_defs" # set CRS
```

Further detail on projecting from one CRS to another in chapter 6.

# 2.4 Units
An important feature of CRSs is that they contain information about spatial units. It is good cartographic practice to add a scale bar onto maps to demonstrate the relationship between distances on the page or screen and distances on the ground. Likewise, it is important to formally specify the units in which the geometry data or pixels are measured to provide context, and ensure that subsequent calculations are done in context.

A novel feature of geometry data in `sf` objects is that they have *native support* for units. This means that distance, area and other geometric calculations in sf return values that come with a units attribute, defined by the `units` package . This is advantageous because it prevents confusion caused by the fact that different CRSs use different units (most use meters, some use feet). Furthermore, it also provides information on dimensionality, as illustrated by the following calculation which reports the area of Luxembourg:
```{r}
luxembourg <- world[world$name_long == "Luxembourg",]
st_area(luxembourg)
```

The result is in units of square meters (m2), showing that the result represents two-dimensional space. This information, stored as an attribute (discover with `attributes(st_area(luxembourg))`) is advantageous for many reasons, for example it could feed into subsequent calculations such as population density. Reporting units prevents confusion. To take the Luxembourg example, if the units remained unspecified, one could incorrectly assume that the units were in hectares. To translate the huge number into a more digestible size, it is tempting to divide the results by a million (the number of square meters in a square kilometer):
```{r}
st_area(luxembourg) / 1000000
```

However, the result is incorrectly given again as square meters. The solution is to set the correct units with the units package:
```{r}
units::set_units(st_area(luxembourg), km^2)
```

Units are of equal importance in the case of raster data. However, so far `sf` is the only spatial package that supports units, meaning that people working on raster data should approach changes in the units of analysis (for example, converting pixel widths from imperial to decimal units) with care. The `new_raster` object (see above) uses a UTM projection with meters as units. Consequently, its resolution is also given in meters but you have to know it, since the res() function simply returns a numeric vector.
```{r}
res(new_raster)
```

If we used the WGS84 projection, the units would change.
```{r}
repr = projectRaster(new_raster, crs = "+init=epsg:4326")
res(repr)
```

Again, the res() command gives back a numeric vector without any unit, forcing us to know that the unit of the WGS84 projection is decimal degrees.

# 2.5 Exercises

  1.  What does the summary of the geometry column tell us about the world dataset, in terms of:
    * The geometry type?  -- Multipolygon
    * How many countries there are? -- 177
    * The coordinate reference system (CRS)? -- WGS84
```{r}
summary(world$geom)
```
    
  2.  Using sf's `plot()` command, create a map of Nigeria in context, building on the code that creates and plots Asia above (see section [2.1.3 basic map making]).
Hint: this used the lwd, main and col arguments of plot().
Bonus: make the country boundaries a dotted gray line.
Hint: border is an additional argument of plot() for sf objects.
```{r}
#create nigeria layer
nga <- world[world$name_long=='Nigeria',]
#create basemap of world
plot(world['pop'],reset=FALSE)
#add nigeria
plot(nga, add=TRUE, col='red',lty=3,border="gray")
```
  3.  What does the cex argument do in the plot() function that generates Figure 2.5? -- It determines the symbol size by making it a function of a country's population.
    * Why was cex set to the sqrt(world$pop) / 10000 instead of just the population directly? To standardize populations, otherwise scale would be too varied to be interpretable/easily visualized.
    * Bonus: what equivalent arguments to cex exist in the dedicated visualization package tmap? Dependent on function, but if using `qtm()`, then `bubble.size` would be one example.
    
  4.  Already done. Main difference is the use of the graticule arg.
  5.  Read the raster/nlcd2011.tif file from the spDataLarge package. What kind of information can you get about the properties of this file? -- Class, dimensions, resolution, extent, CRS & projection
```{r}
raster_filepath = system.file("raster/nlcd2011.tif", package = "spDataLarge")
new_raster5 = raster(raster_filepath)
new_raster5
```

  6.  Create an empty RasterLayer object called my_raster with 10 columns and 10 rows and resolution of 10 units. Assign random values between 0 and 10 to the new raster and plot it.
```{r}
#not working for some reason
my_raster2 <- raster(nrow = 10, ncol = 10, res = 0.5,
                     xmn=-1.5,xmx=1.5,ymn=-1.5,ymx=1.5,
                     vals=sample(0:10,100,replace = T))

```
  